# 医问 3.0 · A0（补充）

## Core Crate 对外 API 设计说明（唯一合法数据入口）

> **本章节目的**
> 明确：
>
> * 健康数据 core crate 对外 **必须提供哪些能力**
> * 外部业务 **通过什么方式操作健康数据**
> * 哪些细节 **被强制屏蔽，不允许外部感知**

---

## 1. 核心结论

医问 3.0 中：

> ✅ **任何对健康数据的写操作，必须通过 core crate 提供的 API 完成**
> ❌ 外部业务不得直接操作数据库表
> ❌ 外部业务不得关心表结构、SQL、事务、连接细节

外部世界只面对一件事：

> **函数调用（API）**

---

## 2. Core Crate 的职责边界

### 2.1 Core Crate 负责什么

Core crate 负责：

* 定义健康数据的领域模型（Subject / Metric / Observation / DataSource）
* 提供 **CRUD 级别的标准化操作接口**
* 维护领域不变量（合法性、完整性）
* 屏蔽数据库实现细节

---

### 2.2 Core Crate 不负责什么（红线）

Core crate **不负责**：

* 数据库连接配置来源（地址、账号、密码）
* 业务级事务编排
* UI / API 层的错误展示
* 趋势、风险、解释逻辑

---

## 3. 对外 API 的设计原则（不是随便写函数）

Core crate 对外 API 必须满足 5 个原则：

1. **以“意图”为中心，而不是表操作**
2. **函数名表达业务语义，而不是 SQL 行为**
3. **外部永远不知道底层是 MySQL / Postgres / SQLite**
4. **外部不需要知道 observation 是几张表**
5. **配置与逻辑严格分离**

---

## 4. 对外 API 能力划分

### 4.1 写入类 API（最重要）

#### 插入 / 记录健康事实

语义级 API 示例（伪代码）：

* `record_observation(...)`

表达的不是：

> insert into observation …

而是：

> **“记录一次健康观测事实”**

最小语义参数：

* subject
* metric
* value
* observed_at
* source（可选）

**外部调用者不需要也不能：**

* 指定表名
* 处理外键
* 管理事务

---

### 4.2 修改类 API（受限）

#### 修改的前提（非常重要）

在 Phase A 的世界里：

> **健康事实原则上不可修改，只能更正**

因此 core crate 中：

* ❌ 不提供任意 update
* ✅ 只提供 **受控的“更正 / 标记失效”能力**

例如语义级 API：

* `amend_observation(...)`
* `invalidate_observation(...)`

这些 API：

* 体现“事实被修正”
* 而不是“随意改历史”

---

### 4.3 删除类 API（极端受限）

删除在健康数据中是 **异常操作**。

core crate 中：

* ❌ 不暴露通用 delete
* ✅ 只允许：

  * 逻辑删除
  * 或合规场景下的受控物理删除

例如：

* `remove_observation_for_compliance(...)`

**删除理由必须显式表达，而不是技术行为。**

---

### 4.4 查询类 API（只做事实层）

core crate 提供：

* 按 subject 查询观测数据
* 按 metric 查询历史序列
* 按时间范围查询

但只返回：

* **事实数据**
* **领域对象**

不返回：

* 趋势
* 状态
* UI 友好结构

---

## 5. 配置与连接方式

### 5.1 配置必须在 crate 外部

Core crate **不内置任何数据库配置**。

外部负责：

* 数据库地址
* 凭证
* 连接池大小
* 环境区分（dev / prod）

Core crate 只接受：

> **一个已经构建好的“数据访问上下文”**

（例如：Repository / Connection / Adapter）

---

### 5.2 Core Crate 对存储的感知程度

允许：

* 定义抽象接口（Repository / Storage Trait）
* 定义 schema 映射结构

不允许：

* 在业务代码中 new 连接
* 在 core crate 中 hardcode 连接信息

---

## 6. 为什么一定要“函数级 API”而不是“暴露表”

这是你这个设计的**灵魂点**。

### 6.1 函数 = 语义边界

函数表达的是：

> **你想做什么**

而不是：

> 你怎么做

一旦外部只能调用函数：

* 表结构可以演进
* 存储引擎可以替换
* 历史数据语义不被破坏

---

### 6.2 函数 = 不变量守门人

只有通过函数：

* 才能保证 Subject / Metric 关系合法
* 才能防止写入“半条事实”
* 才能防止业务层偷塞解释字段

---

## 7. 判断这个 API 设计是否成功的标准

你可以用这 3 条直接验收：

1. **业务工程师是否完全不需要知道 observation 表长什么样？**
2. **换数据库实现，业务代码是否 0 改动？**
3. **未来新增约束，是否只需要改 core crate？**

如果都是 Yes → 这个 crate 才是真的“独立”。

---

## 8. 一句话总结（收口）

> **这个 Core Crate 不只是“数据模型”，
> 而是：
> 健康数据世界的唯一合法出入口。**
>
> 所有业务只能表达“我要做什么”，
> 而不能决定“事实该怎么存”。
